import { openBlock as v, createElementBlock as d, createElementVNode as T, resolveComponent as he, withModifiers as j, createVNode as q, Transition as dt, withCtx as mt, withDirectives as ke, Fragment as Ye, renderList as Fe, createCommentVNode as W, normalizeClass as Z, normalizeStyle as ei, renderSlot as Q, vShow as Be, createTextVNode as ti, toDisplayString as pt, createApp as ii } from "vue";
const K = (l, o) => {
  const f = l.__vccOpts || l;
  for (const [J, a] of o)
    f[J] = a;
  return f;
}, ni = {}, ri = /* @__PURE__ */ T("svg", {
  fill: "white",
  x: "0px",
  y: "0px",
  width: "100%",
  height: "100%",
  viewBox: "0 0 512 512"
}, [
  /* @__PURE__ */ T("path", { d: "M213.7,256L213.7,256L213.7,256L380.9,81.9c4.2-4.3,4.1-11.4-0.2-15.8l-29.9-30.6c-4.3-4.4-11.3-4.5-15.5-0.2L131.1,247.9 c-2.2,2.2-3.2,5.2-3,8.1c-0.1,3,0.9,5.9,3,8.1l204.2,212.7c4.2,4.3,11.2,4.2,15.5-0.2l29.9-30.6c4.3-4.4,4.4-11.5,0.2-15.8 L213.7,256z" })
], -1), si = [
  ri
];
function oi(l, o) {
  return v(), d("span", null, si);
}
const ai = /* @__PURE__ */ K(ni, [["render", oi]]), li = {}, hi = /* @__PURE__ */ T("svg", {
  fill: "white",
  x: "0px",
  y: "0px",
  width: "100%",
  height: "100%",
  viewBox: "0 0 512 512"
}, [
  /* @__PURE__ */ T("path", { d: "M298.3,256L298.3,256L298.3,256L131.1,81.9c-4.2-4.3-4.1-11.4,0.2-15.8l29.9-30.6c4.3-4.4,11.3-4.5,15.5-0.2l204.2,212.7 c2.2,2.2,3.2,5.2,3,8.1c0.1,3-0.9,5.9-3,8.1L176.7,476.8c-4.2,4.3-11.2,4.2-15.5-0.2L131.3,446c-4.3-4.4-4.4-11.5-0.2-15.8 L298.3,256z" })
], -1), ci = [
  hi
];
function ui(l, o) {
  return v(), d("span", null, ci);
}
const fi = /* @__PURE__ */ K(li, [["render", ui]]), vi = {}, di = {
  fill: "white",
  x: "0px",
  y: "0px",
  width: "100%",
  height: "100%",
  viewBox: "0 0 512 512",
  style: { "enable-background": "new 0 0 512 512" }
}, mi = /* @__PURE__ */ T("path", { d: "M443.6,387.1L312.4,255.4l131.5-130c5.4-5.4,5.4-14.2,0-19.6l-37.4-37.6c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4 L256,197.8L124.9,68.3c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4L68,105.9c-5.4,5.4-5.4,14.2,0,19.6l131.5,130L68.4,387.1 c-2.6,2.6-4.1,6.1-4.1,9.8c0,3.7,1.4,7.2,4.1,9.8l37.4,37.6c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1L256,313.1l130.7,131.1 c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1l37.4-37.6c2.6-2.6,4.1-6.1,4.1-9.8C447.7,393.2,446.2,389.7,443.6,387.1z" }, null, -1), pi = [
  mi
];
function gi(l, o) {
  return v(), d("span", null, [
    (v(), d("svg", di, pi))
  ]);
}
const Ti = /* @__PURE__ */ K(vi, [["render", gi]]), yi = {}, Ei = {
  x: "0px",
  y: "0px",
  viewBox: "0 0 271.953 271.953",
  style: { "enable-background": "new 0 0 271.953 271.953", margin: "12px" },
  "xml:space": "preserve"
}, _i = /* @__PURE__ */ T("g", null, [
  /* @__PURE__ */ T("g", null, [
    /* @__PURE__ */ T("path", {
      style: { fill: "#fff" },
      d: "M135.977,271.953c75.097,0,135.977-60.879,135.977-135.977S211.074,0,135.977,0S0,60.879,0,135.977    S60.879,271.953,135.977,271.953z M250.197,135.977c0,62.979-51.241,114.22-114.22,114.22s-114.22-51.241-114.22-114.22    s51.241-114.22,114.22-114.22S250.197,72.998,250.197,135.977z"
    }),
    /* @__PURE__ */ T("path", {
      style: { fill: "#fff" },
      d: "M112.295,205.031c2.692,1.115,5.434,1.659,8.235,1.659c5.662,0,11.183-2.208,15.344-6.375    l48.93-48.952c8.496-8.496,8.485-22.273-0.011-30.769l-48.957-48.952c-4.161-4.161-9.73-6.375-15.393-6.375    c-2.801,0-5.461,0.544-8.153,1.659c-8.126,3.367-13.255,11.297-13.255,20.097v97.903    C99.034,193.729,104.164,201.664,112.295,205.031z M120.791,88.613v-1.588l48.952,48.952l-48.952,48.952V88.613z"
    })
  ])
], -1), Ii = [
  _i
];
function bi(l, o) {
  return v(), d("svg", Ei, Ii);
}
const Ci = /* @__PURE__ */ K(yi, [["render", bi]]);
function Ai(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var gt = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(l) {
  (function(o, f, J, a) {
    var c = ["", "webkit", "Moz", "MS", "ms", "o"], $ = f.createElement("div"), ee = "function", N = Math.round, M = Math.abs, u = Date.now;
    function S(e, t, i) {
      return setTimeout(Ae(e, i), t);
    }
    function B(e, t, i) {
      return Array.isArray(e) ? (D(e, i[t], i), !0) : !1;
    }
    function D(e, t, i) {
      var n;
      if (e)
        if (e.forEach)
          e.forEach(t, i);
        else if (e.length !== a)
          for (n = 0; n < e.length; )
            t.call(i, e[n], n, e), n++;
        else
          for (n in e)
            e.hasOwnProperty(n) && t.call(i, e[n], n, e);
    }
    function Ve(e, t, i) {
      var n = "DEPRECATED METHOD: " + t + `
` + i + ` AT 
`;
      return function() {
        var r = new Error("get-stack-trace"), s = r && r.stack ? r.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", h = o.console && (o.console.warn || o.console.log);
        return h && h.call(o.console, n, s), e.apply(this, arguments);
      };
    }
    var O;
    typeof Object.assign != "function" ? O = function(t) {
      if (t === a || t === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var i = Object(t), n = 1; n < arguments.length; n++) {
        var r = arguments[n];
        if (r !== a && r !== null)
          for (var s in r)
            r.hasOwnProperty(s) && (i[s] = r[s]);
      }
      return i;
    } : O = Object.assign;
    var Xe = Ve(function(t, i, n) {
      for (var r = Object.keys(i), s = 0; s < r.length; )
        (!n || n && t[r[s]] === a) && (t[r[s]] = i[r[s]]), s++;
      return t;
    }, "extend", "Use `assign`."), Tt = Ve(function(t, i) {
      return Xe(t, i, !0);
    }, "merge", "Use `assign`.");
    function b(e, t, i) {
      var n = t.prototype, r;
      r = e.prototype = Object.create(n), r.constructor = e, r._super = n, i && O(r, i);
    }
    function Ae(e, t) {
      return function() {
        return e.apply(t, arguments);
      };
    }
    function Ne(e, t) {
      return typeof e == ee ? e.apply(t && t[0] || a, t) : e;
    }
    function We(e, t) {
      return e === a ? t : e;
    }
    function ce(e, t, i) {
      D(fe(t), function(n) {
        e.addEventListener(n, i, !1);
      });
    }
    function ue(e, t, i) {
      D(fe(t), function(n) {
        e.removeEventListener(n, i, !1);
      });
    }
    function qe(e, t) {
      for (; e; ) {
        if (e == t)
          return !0;
        e = e.parentNode;
      }
      return !1;
    }
    function Y(e, t) {
      return e.indexOf(t) > -1;
    }
    function fe(e) {
      return e.trim().split(/\s+/g);
    }
    function z(e, t, i) {
      if (e.indexOf && !i)
        return e.indexOf(t);
      for (var n = 0; n < e.length; ) {
        if (i && e[n][i] == t || !i && e[n] === t)
          return n;
        n++;
      }
      return -1;
    }
    function ve(e) {
      return Array.prototype.slice.call(e, 0);
    }
    function ze(e, t, i) {
      for (var n = [], r = [], s = 0; s < e.length; ) {
        var h = t ? e[s][t] : e[s];
        z(r, h) < 0 && n.push(e[s]), r[s] = h, s++;
      }
      return i && (t ? n = n.sort(function(g, _) {
        return g[t] > _[t];
      }) : n = n.sort()), n;
    }
    function de(e, t) {
      for (var i, n, r = t[0].toUpperCase() + t.slice(1), s = 0; s < c.length; ) {
        if (i = c[s], n = i ? i + r : t, n in e)
          return n;
        s++;
      }
      return a;
    }
    var yt = 1;
    function Et() {
      return yt++;
    }
    function Ge(e) {
      var t = e.ownerDocument || e;
      return t.defaultView || t.parentWindow || o;
    }
    var _t = /mobile|tablet|ip(ad|hone|od)|android/i, je = "ontouchstart" in o, It = de(o, "PointerEvent") !== a, bt = je && _t.test(navigator.userAgent), te = "touch", Ct = "pen", Pe = "mouse", At = "kinect", Nt = 25, E = 1, F = 2, m = 4, I = 8, me = 1, ie = 2, ne = 4, re = 8, se = 16, x = ie | ne, V = re | se, Ze = x | V, Qe = ["x", "y"], pe = ["clientX", "clientY"];
    function C(e, t) {
      var i = this;
      this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function(n) {
        Ne(e.options.enable, [e]) && i.handler(n);
      }, this.init();
    }
    C.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && ce(this.element, this.evEl, this.domHandler), this.evTarget && ce(this.target, this.evTarget, this.domHandler), this.evWin && ce(Ge(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && ue(this.element, this.evEl, this.domHandler), this.evTarget && ue(this.target, this.evTarget, this.domHandler), this.evWin && ue(Ge(this.element), this.evWin, this.domHandler);
      }
    };
    function Pt(e) {
      var t, i = e.options.inputClass;
      return i ? t = i : It ? t = Se : bt ? t = ye : je ? t = Oe : t = Te, new t(e, Mt);
    }
    function Mt(e, t, i) {
      var n = i.pointers.length, r = i.changedPointers.length, s = t & E && n - r === 0, h = t & (m | I) && n - r === 0;
      i.isFirst = !!s, i.isFinal = !!h, s && (e.session = {}), i.eventType = t, St(e, i), e.emit("hammer.input", i), e.recognize(i), e.session.prevInput = i;
    }
    function St(e, t) {
      var i = e.session, n = t.pointers, r = n.length;
      i.firstInput || (i.firstInput = Ke(t)), r > 1 && !i.firstMultiple ? i.firstMultiple = Ke(t) : r === 1 && (i.firstMultiple = !1);
      var s = i.firstInput, h = i.firstMultiple, p = h ? h.center : s.center, g = t.center = Je(n);
      t.timeStamp = u(), t.deltaTime = t.timeStamp - s.timeStamp, t.angle = Me(p, g), t.distance = ge(p, g), Ot(i, t), t.offsetDirection = et(t.deltaX, t.deltaY);
      var _ = $e(t.deltaTime, t.deltaX, t.deltaY);
      t.overallVelocityX = _.x, t.overallVelocityY = _.y, t.overallVelocity = M(_.x) > M(_.y) ? _.x : _.y, t.scale = h ? wt(h.pointers, n) : 1, t.rotation = h ? Lt(h.pointers, n) : 0, t.maxPointers = i.prevInput ? t.pointers.length > i.prevInput.maxPointers ? t.pointers.length : i.prevInput.maxPointers : t.pointers.length, xt(i, t);
      var w = e.element;
      qe(t.srcEvent.target, w) && (w = t.srcEvent.target), t.target = w;
    }
    function Ot(e, t) {
      var i = t.center, n = e.offsetDelta || {}, r = e.prevDelta || {}, s = e.prevInput || {};
      (t.eventType === E || s.eventType === m) && (r = e.prevDelta = {
        x: s.deltaX || 0,
        y: s.deltaY || 0
      }, n = e.offsetDelta = {
        x: i.x,
        y: i.y
      }), t.deltaX = r.x + (i.x - n.x), t.deltaY = r.y + (i.y - n.y);
    }
    function xt(e, t) {
      var i = e.lastInterval || t, n = t.timeStamp - i.timeStamp, r, s, h, p;
      if (t.eventType != I && (n > Nt || i.velocity === a)) {
        var g = t.deltaX - i.deltaX, _ = t.deltaY - i.deltaY, w = $e(n, g, _);
        s = w.x, h = w.y, r = M(w.x) > M(w.y) ? w.x : w.y, p = et(g, _), e.lastInterval = t;
      } else
        r = i.velocity, s = i.velocityX, h = i.velocityY, p = i.direction;
      t.velocity = r, t.velocityX = s, t.velocityY = h, t.direction = p;
    }
    function Ke(e) {
      for (var t = [], i = 0; i < e.pointers.length; )
        t[i] = {
          clientX: N(e.pointers[i].clientX),
          clientY: N(e.pointers[i].clientY)
        }, i++;
      return {
        timeStamp: u(),
        pointers: t,
        center: Je(t),
        deltaX: e.deltaX,
        deltaY: e.deltaY
      };
    }
    function Je(e) {
      var t = e.length;
      if (t === 1)
        return {
          x: N(e[0].clientX),
          y: N(e[0].clientY)
        };
      for (var i = 0, n = 0, r = 0; r < t; )
        i += e[r].clientX, n += e[r].clientY, r++;
      return {
        x: N(i / t),
        y: N(n / t)
      };
    }
    function $e(e, t, i) {
      return {
        x: t / e || 0,
        y: i / e || 0
      };
    }
    function et(e, t) {
      return e === t ? me : M(e) >= M(t) ? e < 0 ? ie : ne : t < 0 ? re : se;
    }
    function ge(e, t, i) {
      i || (i = Qe);
      var n = t[i[0]] - e[i[0]], r = t[i[1]] - e[i[1]];
      return Math.sqrt(n * n + r * r);
    }
    function Me(e, t, i) {
      i || (i = Qe);
      var n = t[i[0]] - e[i[0]], r = t[i[1]] - e[i[1]];
      return Math.atan2(r, n) * 180 / Math.PI;
    }
    function Lt(e, t) {
      return Me(t[1], t[0], pe) + Me(e[1], e[0], pe);
    }
    function wt(e, t) {
      return ge(t[0], t[1], pe) / ge(e[0], e[1], pe);
    }
    var Dt = {
      mousedown: E,
      mousemove: F,
      mouseup: m
    }, Ht = "mousedown", Rt = "mousemove mouseup";
    function Te() {
      this.evEl = Ht, this.evWin = Rt, this.pressed = !1, C.apply(this, arguments);
    }
    b(Te, C, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(t) {
        var i = Dt[t.type];
        i & E && t.button === 0 && (this.pressed = !0), i & F && t.which !== 1 && (i = m), this.pressed && (i & m && (this.pressed = !1), this.callback(this.manager, i, {
          pointers: [t],
          changedPointers: [t],
          pointerType: Pe,
          srcEvent: t
        }));
      }
    });
    var Ut = {
      pointerdown: E,
      pointermove: F,
      pointerup: m,
      pointercancel: I,
      pointerout: I
    }, kt = {
      2: te,
      3: Ct,
      4: Pe,
      5: At
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, tt = "pointerdown", it = "pointermove pointerup pointercancel";
    o.MSPointerEvent && !o.PointerEvent && (tt = "MSPointerDown", it = "MSPointerMove MSPointerUp MSPointerCancel");
    function Se() {
      this.evEl = tt, this.evWin = it, C.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    b(Se, C, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(t) {
        var i = this.store, n = !1, r = t.type.toLowerCase().replace("ms", ""), s = Ut[r], h = kt[t.pointerType] || t.pointerType, p = h == te, g = z(i, t.pointerId, "pointerId");
        s & E && (t.button === 0 || p) ? g < 0 && (i.push(t), g = i.length - 1) : s & (m | I) && (n = !0), !(g < 0) && (i[g] = t, this.callback(this.manager, s, {
          pointers: i,
          changedPointers: [t],
          pointerType: h,
          srcEvent: t
        }), n && i.splice(g, 1));
      }
    });
    var Bt = {
      touchstart: E,
      touchmove: F,
      touchend: m,
      touchcancel: I
    }, Yt = "touchstart", Ft = "touchstart touchmove touchend touchcancel";
    function nt() {
      this.evTarget = Yt, this.evWin = Ft, this.started = !1, C.apply(this, arguments);
    }
    b(nt, C, {
      handler: function(t) {
        var i = Bt[t.type];
        if (i === E && (this.started = !0), !!this.started) {
          var n = Vt.call(this, t, i);
          i & (m | I) && n[0].length - n[1].length === 0 && (this.started = !1), this.callback(this.manager, i, {
            pointers: n[0],
            changedPointers: n[1],
            pointerType: te,
            srcEvent: t
          });
        }
      }
    });
    function Vt(e, t) {
      var i = ve(e.touches), n = ve(e.changedTouches);
      return t & (m | I) && (i = ze(i.concat(n), "identifier", !0)), [i, n];
    }
    var Xt = {
      touchstart: E,
      touchmove: F,
      touchend: m,
      touchcancel: I
    }, Wt = "touchstart touchmove touchend touchcancel";
    function ye() {
      this.evTarget = Wt, this.targetIds = {}, C.apply(this, arguments);
    }
    b(ye, C, {
      handler: function(t) {
        var i = Xt[t.type], n = qt.call(this, t, i);
        n && this.callback(this.manager, i, {
          pointers: n[0],
          changedPointers: n[1],
          pointerType: te,
          srcEvent: t
        });
      }
    });
    function qt(e, t) {
      var i = ve(e.touches), n = this.targetIds;
      if (t & (E | F) && i.length === 1)
        return n[i[0].identifier] = !0, [i, i];
      var r, s, h = ve(e.changedTouches), p = [], g = this.target;
      if (s = i.filter(function(_) {
        return qe(_.target, g);
      }), t === E)
        for (r = 0; r < s.length; )
          n[s[r].identifier] = !0, r++;
      for (r = 0; r < h.length; )
        n[h[r].identifier] && p.push(h[r]), t & (m | I) && delete n[h[r].identifier], r++;
      if (p.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          ze(s.concat(p), "identifier", !0),
          p
        ];
    }
    var zt = 2500, rt = 25;
    function Oe() {
      C.apply(this, arguments);
      var e = Ae(this.handler, this);
      this.touch = new ye(this.manager, e), this.mouse = new Te(this.manager, e), this.primaryTouch = null, this.lastTouches = [];
    }
    b(Oe, C, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(t, i, n) {
        var r = n.pointerType == te, s = n.pointerType == Pe;
        if (!(s && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) {
          if (r)
            Gt.call(this, i, n);
          else if (s && jt.call(this, n))
            return;
          this.callback(t, i, n);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function Gt(e, t) {
      e & E ? (this.primaryTouch = t.changedPointers[0].identifier, st.call(this, t)) : e & (m | I) && st.call(this, t);
    }
    function st(e) {
      var t = e.changedPointers[0];
      if (t.identifier === this.primaryTouch) {
        var i = { x: t.clientX, y: t.clientY };
        this.lastTouches.push(i);
        var n = this.lastTouches, r = function() {
          var s = n.indexOf(i);
          s > -1 && n.splice(s, 1);
        };
        setTimeout(r, zt);
      }
    }
    function jt(e) {
      for (var t = e.srcEvent.clientX, i = e.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
        var r = this.lastTouches[n], s = Math.abs(t - r.x), h = Math.abs(i - r.y);
        if (s <= rt && h <= rt)
          return !0;
      }
      return !1;
    }
    var ot = de($.style, "touchAction"), at = ot !== a, lt = "compute", ht = "auto", xe = "manipulation", X = "none", oe = "pan-x", ae = "pan-y", Ee = Qt();
    function Le(e, t) {
      this.manager = e, this.set(t);
    }
    Le.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(e) {
        e == lt && (e = this.compute()), at && this.manager.element.style && Ee[e] && (this.manager.element.style[ot] = e), this.actions = e.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var e = [];
        return D(this.manager.recognizers, function(t) {
          Ne(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()));
        }), Zt(e.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(e) {
        var t = e.srcEvent, i = e.offsetDirection;
        if (this.manager.session.prevented) {
          t.preventDefault();
          return;
        }
        var n = this.actions, r = Y(n, X) && !Ee[X], s = Y(n, ae) && !Ee[ae], h = Y(n, oe) && !Ee[oe];
        if (r) {
          var p = e.pointers.length === 1, g = e.distance < 2, _ = e.deltaTime < 250;
          if (p && g && _)
            return;
        }
        if (!(h && s) && (r || s && i & x || h && i & V))
          return this.preventSrc(t);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(e) {
        this.manager.session.prevented = !0, e.preventDefault();
      }
    };
    function Zt(e) {
      if (Y(e, X))
        return X;
      var t = Y(e, oe), i = Y(e, ae);
      return t && i ? X : t || i ? t ? oe : ae : Y(e, xe) ? xe : ht;
    }
    function Qt() {
      if (!at)
        return !1;
      var e = {}, t = o.CSS && o.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(i) {
        e[i] = t ? o.CSS.supports("touch-action", i) : !0;
      }), e;
    }
    var _e = 1, A = 2, G = 4, k = 8, H = k, le = 16, L = 32;
    function R(e) {
      this.options = O({}, this.defaults, e || {}), this.id = Et(), this.manager = null, this.options.enable = We(this.options.enable, !0), this.state = _e, this.simultaneous = {}, this.requireFail = [];
    }
    R.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(e) {
        return O(this.options, e), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(e) {
        if (B(e, "recognizeWith", this))
          return this;
        var t = this.simultaneous;
        return e = Ie(e, this), t[e.id] || (t[e.id] = e, e.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(e) {
        return B(e, "dropRecognizeWith", this) ? this : (e = Ie(e, this), delete this.simultaneous[e.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(e) {
        if (B(e, "requireFailure", this))
          return this;
        var t = this.requireFail;
        return e = Ie(e, this), z(t, e) === -1 && (t.push(e), e.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(e) {
        if (B(e, "dropRequireFailure", this))
          return this;
        e = Ie(e, this);
        var t = z(this.requireFail, e);
        return t > -1 && this.requireFail.splice(t, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(e) {
        return !!this.simultaneous[e.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(e) {
        var t = this, i = this.state;
        function n(r) {
          t.manager.emit(r, e);
        }
        i < k && n(t.options.event + ct(i)), n(t.options.event), e.additionalEvent && n(e.additionalEvent), i >= k && n(t.options.event + ct(i));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(e) {
        if (this.canEmit())
          return this.emit(e);
        this.state = L;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var e = 0; e < this.requireFail.length; ) {
          if (!(this.requireFail[e].state & (L | _e)))
            return !1;
          e++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(e) {
        var t = O({}, e);
        if (!Ne(this.options.enable, [this, t])) {
          this.reset(), this.state = L;
          return;
        }
        this.state & (H | le | L) && (this.state = _e), this.state = this.process(t), this.state & (A | G | k | le) && this.tryEmit(t);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(e) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function ct(e) {
      return e & le ? "cancel" : e & k ? "end" : e & G ? "move" : e & A ? "start" : "";
    }
    function ut(e) {
      return e == se ? "down" : e == re ? "up" : e == ie ? "left" : e == ne ? "right" : "";
    }
    function Ie(e, t) {
      var i = t.manager;
      return i ? i.get(e) : e;
    }
    function P() {
      R.apply(this, arguments);
    }
    b(P, R, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(e) {
        var t = this.options.pointers;
        return t === 0 || e.pointers.length === t;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(e) {
        var t = this.state, i = e.eventType, n = t & (A | G), r = this.attrTest(e);
        return n && (i & I || !r) ? t | le : n || r ? i & m ? t | k : t & A ? t | G : A : L;
      }
    });
    function be() {
      P.apply(this, arguments), this.pX = null, this.pY = null;
    }
    b(be, P, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: Ze
      },
      getTouchAction: function() {
        var e = this.options.direction, t = [];
        return e & x && t.push(ae), e & V && t.push(oe), t;
      },
      directionTest: function(e) {
        var t = this.options, i = !0, n = e.distance, r = e.direction, s = e.deltaX, h = e.deltaY;
        return r & t.direction || (t.direction & x ? (r = s === 0 ? me : s < 0 ? ie : ne, i = s != this.pX, n = Math.abs(e.deltaX)) : (r = h === 0 ? me : h < 0 ? re : se, i = h != this.pY, n = Math.abs(e.deltaY))), e.direction = r, i && n > t.threshold && r & t.direction;
      },
      attrTest: function(e) {
        return P.prototype.attrTest.call(this, e) && (this.state & A || !(this.state & A) && this.directionTest(e));
      },
      emit: function(e) {
        this.pX = e.deltaX, this.pY = e.deltaY;
        var t = ut(e.direction);
        t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e);
      }
    });
    function we() {
      P.apply(this, arguments);
    }
    b(we, P, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [X];
      },
      attrTest: function(e) {
        return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & A);
      },
      emit: function(e) {
        if (e.scale !== 1) {
          var t = e.scale < 1 ? "in" : "out";
          e.additionalEvent = this.options.event + t;
        }
        this._super.emit.call(this, e);
      }
    });
    function De() {
      R.apply(this, arguments), this._timer = null, this._input = null;
    }
    b(De, R, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [ht];
      },
      process: function(e) {
        var t = this.options, i = e.pointers.length === t.pointers, n = e.distance < t.threshold, r = e.deltaTime > t.time;
        if (this._input = e, !n || !i || e.eventType & (m | I) && !r)
          this.reset();
        else if (e.eventType & E)
          this.reset(), this._timer = S(function() {
            this.state = H, this.tryEmit();
          }, t.time, this);
        else if (e.eventType & m)
          return H;
        return L;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(e) {
        this.state === H && (e && e.eventType & m ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = u(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function He() {
      P.apply(this, arguments);
    }
    b(He, P, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [X];
      },
      attrTest: function(e) {
        return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & A);
      }
    });
    function Re() {
      P.apply(this, arguments);
    }
    b(Re, P, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: x | V,
        pointers: 1
      },
      getTouchAction: function() {
        return be.prototype.getTouchAction.call(this);
      },
      attrTest: function(e) {
        var t = this.options.direction, i;
        return t & (x | V) ? i = e.overallVelocity : t & x ? i = e.overallVelocityX : t & V && (i = e.overallVelocityY), this._super.attrTest.call(this, e) && t & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && M(i) > this.options.velocity && e.eventType & m;
      },
      emit: function(e) {
        var t = ut(e.offsetDirection);
        t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e);
      }
    });
    function Ce() {
      R.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    b(Ce, R, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [xe];
      },
      process: function(e) {
        var t = this.options, i = e.pointers.length === t.pointers, n = e.distance < t.threshold, r = e.deltaTime < t.time;
        if (this.reset(), e.eventType & E && this.count === 0)
          return this.failTimeout();
        if (n && r && i) {
          if (e.eventType != m)
            return this.failTimeout();
          var s = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, h = !this.pCenter || ge(this.pCenter, e.center) < t.posThreshold;
          this.pTime = e.timeStamp, this.pCenter = e.center, !h || !s ? this.count = 1 : this.count += 1, this._input = e;
          var p = this.count % t.taps;
          if (p === 0)
            return this.hasRequireFailures() ? (this._timer = S(function() {
              this.state = H, this.tryEmit();
            }, t.interval, this), A) : H;
        }
        return L;
      },
      failTimeout: function() {
        return this._timer = S(function() {
          this.state = L;
        }, this.options.interval, this), L;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == H && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function U(e, t) {
      return t = t || {}, t.recognizers = We(t.recognizers, U.defaults.preset), new Ue(e, t);
    }
    U.VERSION = "2.0.7", U.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: lt,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [He, { enable: !1 }],
        [we, { enable: !1 }, ["rotate"]],
        [Re, { direction: x }],
        [be, { direction: x }, ["swipe"]],
        [Ce],
        [Ce, { event: "doubletap", taps: 2 }, ["tap"]],
        [De]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var Kt = 1, ft = 2;
    function Ue(e, t) {
      this.options = O({}, U.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = Pt(this), this.touchAction = new Le(this, this.options.touchAction), vt(this, !0), D(this.options.recognizers, function(i) {
        var n = this.add(new i[0](i[1]));
        i[2] && n.recognizeWith(i[2]), i[3] && n.requireFailure(i[3]);
      }, this);
    }
    Ue.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(e) {
        return O(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(e) {
        this.session.stopped = e ? ft : Kt;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(e) {
        var t = this.session;
        if (!t.stopped) {
          this.touchAction.preventDefaults(e);
          var i, n = this.recognizers, r = t.curRecognizer;
          (!r || r && r.state & H) && (r = t.curRecognizer = null);
          for (var s = 0; s < n.length; )
            i = n[s], t.stopped !== ft && // 1
            (!r || i == r || // 2
            i.canRecognizeWith(r)) ? i.recognize(e) : i.reset(), !r && i.state & (A | G | k) && (r = t.curRecognizer = i), s++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(e) {
        if (e instanceof R)
          return e;
        for (var t = this.recognizers, i = 0; i < t.length; i++)
          if (t[i].options.event == e)
            return t[i];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(e) {
        if (B(e, "add", this))
          return this;
        var t = this.get(e.options.event);
        return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(e) {
        if (B(e, "remove", this))
          return this;
        if (e = this.get(e), e) {
          var t = this.recognizers, i = z(t, e);
          i !== -1 && (t.splice(i, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(e, t) {
        if (e !== a && t !== a) {
          var i = this.handlers;
          return D(fe(e), function(n) {
            i[n] = i[n] || [], i[n].push(t);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(e, t) {
        if (e !== a) {
          var i = this.handlers;
          return D(fe(e), function(n) {
            t ? i[n] && i[n].splice(z(i[n], t), 1) : delete i[n];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(e, t) {
        this.options.domEvents && Jt(e, t);
        var i = this.handlers[e] && this.handlers[e].slice();
        if (!(!i || !i.length)) {
          t.type = e, t.preventDefault = function() {
            t.srcEvent.preventDefault();
          };
          for (var n = 0; n < i.length; )
            i[n](t), n++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && vt(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function vt(e, t) {
      var i = e.element;
      if (i.style) {
        var n;
        D(e.options.cssProps, function(r, s) {
          n = de(i.style, s), t ? (e.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = e.oldCssProps[n] || "";
        }), t || (e.oldCssProps = {});
      }
    }
    function Jt(e, t) {
      var i = f.createEvent("Event");
      i.initEvent(e, !0, !0), i.gesture = t, t.target.dispatchEvent(i);
    }
    O(U, {
      INPUT_START: E,
      INPUT_MOVE: F,
      INPUT_END: m,
      INPUT_CANCEL: I,
      STATE_POSSIBLE: _e,
      STATE_BEGAN: A,
      STATE_CHANGED: G,
      STATE_ENDED: k,
      STATE_RECOGNIZED: H,
      STATE_CANCELLED: le,
      STATE_FAILED: L,
      DIRECTION_NONE: me,
      DIRECTION_LEFT: ie,
      DIRECTION_RIGHT: ne,
      DIRECTION_UP: re,
      DIRECTION_DOWN: se,
      DIRECTION_HORIZONTAL: x,
      DIRECTION_VERTICAL: V,
      DIRECTION_ALL: Ze,
      Manager: Ue,
      Input: C,
      TouchAction: Le,
      TouchInput: ye,
      MouseInput: Te,
      PointerEventInput: Se,
      TouchMouseInput: Oe,
      SingleTouchInput: nt,
      Recognizer: R,
      AttrRecognizer: P,
      Tap: Ce,
      Pan: be,
      Swipe: Re,
      Pinch: we,
      Rotate: He,
      Press: De,
      on: ce,
      off: ue,
      each: D,
      merge: Tt,
      extend: Xe,
      assign: O,
      inherit: b,
      bindFn: Ae,
      prefixed: de
    });
    var $t = typeof o < "u" ? o : typeof self < "u" ? self : {};
    $t.Hammer = U, typeof a == "function" && a.amd ? a(function() {
      return U;
    }) : l.exports ? l.exports = U : o[J] = U;
  })(window, document, "Hammer");
})(gt);
var Ni = gt.exports;
const Pi = /* @__PURE__ */ Ai(Ni);
const Mi = {
  components: {
    LeftArrowIcon: ai,
    RightArrowIcon: fi,
    CloseIcon: Ti,
    VideoIcon: Ci
  },
  props: {
    media: {
      type: Array,
      required: !0
    },
    disableScroll: {
      type: Boolean,
      default: !0
    },
    showLightBox: {
      type: Boolean,
      default: !0
    },
    closable: {
      type: Boolean,
      default: !0
    },
    startAt: {
      type: Number,
      default: 0
    },
    nThumbs: {
      type: Number,
      default: 7
    },
    showThumbs: {
      type: Boolean,
      default: !0
    },
    // Mode
    autoPlay: {
      type: Boolean,
      default: !1
    },
    autoPlayTime: {
      type: Number,
      default: 3e3
    },
    interfaceHideTime: {
      type: Number,
      default: 3e3
    },
    showCaption: {
      type: Boolean,
      default: !1
    },
    lengthToLoadMore: {
      type: Number,
      default: 0
    },
    closeText: {
      type: String,
      default: "Close (Esc)"
    },
    previousText: {
      type: String,
      default: "Previous"
    },
    nextText: {
      type: String,
      default: "Next"
    }
  },
  data() {
    return {
      select: this.startAt,
      lightBoxShown: this.showLightBox,
      controlsHidden: !1,
      imageTransitionName: "vib-image-no-transition",
      timer: null,
      interactionTimer: null,
      interfaceHovered: !1
    };
  },
  computed: {
    currentMedia() {
      return this.media[this.select];
    },
    thumbIndex() {
      const l = Math.floor(this.nThumbs / 2);
      return this.select >= l && this.select < this.media.length - l ? {
        begin: this.select - l + (1 - this.nThumbs % 2),
        end: this.select + l
      } : this.select < l ? {
        begin: 0,
        end: this.nThumbs - 1
      } : {
        begin: this.media.length - this.nThumbs,
        end: this.media.length - 1
      };
    },
    imagesThumb() {
      return this.media.map(({ thumb: l, type: o }) => ({ thumb: l, type: o }));
    }
  },
  watch: {
    lightBoxShown(l) {
      document != null && this.onToggleLightBox(l);
    },
    select() {
      this.$emit("onImageChanged", this.select), this.select >= this.media.length - this.lengthToLoadMore - 1 && this.$emit("onLoad"), this.select === this.media.length - 1 && this.$emit("onLastIndex"), this.select === 0 && this.$emit("onFirstIndex"), this.select === this.startAt && this.$emit("onStartIndex");
    }
  },
  mounted() {
    if (this.autoPlay && (this.timer = setInterval(this.nextImage, this.autoPlayTime)), this.onToggleLightBox(this.lightBoxShown), this.$refs.container) {
      const l = new Pi(this.$refs.container);
      l.on("swiperight", this.previousImage), l.on("swipeleft", this.nextImage), this.$refs.container.addEventListener("mousedown", this.handleMouseActivity), this.$refs.container.addEventListener("mousemove", this.handleMouseActivity), this.$refs.container.addEventListener("touchmove", this.handleMouseActivity);
    }
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.addKeyEvent), this.autoPlay && clearInterval(this.timer), this.$refs.container && (this.$refs.container.removeEventListener("mousedown", this.handleMouseActivity), this.$refs.container.removeEventListener("mousemove", this.handleMouseActivity), this.$refs.container.removeEventListener("touchmove", this.handleMouseActivity));
  },
  methods: {
    onLightBoxOpen() {
      this.$emit("onOpened"), this.disableScroll && document.querySelector("html").classList.add("no-scroll"), document.querySelector("body").classList.add("vib-open"), document.addEventListener("keydown", this.addKeyEvent), this.$refs.video && this.$refs.video.autoplay && this.$refs.video.play();
    },
    onLightBoxClose() {
      this.$emit("onClosed"), this.disableScroll && document.querySelector("html").classList.remove("no-scroll"), document.querySelector("body").classList.remove("vib-open"), document.removeEventListener("keydown", this.addKeyEvent), this.$refs.video && (this.$refs.video.pause(), this.$refs.video.currentTime = "0");
    },
    onToggleLightBox(l) {
      l ? this.onLightBoxOpen() : this.onLightBoxClose();
    },
    showImage(l) {
      this.select = l, this.controlsHidden = !1, this.lightBoxShown = !0;
    },
    addKeyEvent(l) {
      switch (l.keyCode) {
        case 37:
          this.previousImage();
          break;
        case 39:
          this.nextImage();
          break;
        case 27:
          this.closeLightBox();
          break;
      }
    },
    closeLightBox() {
      this.$refs.video && this.$refs.video.pause(), this.closable && (this.lightBoxShown = !1);
    },
    nextImage() {
      this.select = (this.select + 1) % this.media.length;
    },
    previousImage() {
      this.select = (this.select + this.media.length - 1) % this.media.length;
    },
    enableImageTransition() {
      this.handleMouseActivity(), this.imageTransitionName = "vib-image-transition";
    },
    disableImageTransition() {
      this.imageTransitionName = "vib-image-no-transition";
    },
    handleMouseActivity() {
      clearTimeout(this.interactionTimer), this.controlsHidden && (this.controlsHidden = !1), this.interfaceHovered ? this.stopInteractionTimer() : this.startInteractionTimer();
    },
    startInteractionTimer() {
      this.interactionTimer = setTimeout(() => {
        this.controlsHidden = !0;
      }, this.interfaceHideTime);
    },
    stopInteractionTimer() {
      this.interactionTimer = null;
    }
  }
}, Si = {
  key: 0,
  ref: "container",
  class: "vib-container"
}, Oi = ["src", "srcset", "alt"], xi = {
  key: 1,
  class: "video-background"
}, Li = ["src"], wi = ["width", "height", "autoplay"], Di = ["src", "type"], Hi = ["onClick"], Ri = ["innerHTML"], Ui = { class: "vib-footer-count" }, ki = ["title"], Bi = ["title"], Yi = ["title"];
function Fi(l, o, f, J, a, c) {
  const $ = he("VideoIcon"), ee = he("CloseIcon"), N = he("LeftArrowIcon"), M = he("RightArrowIcon");
  return v(), d("div", {
    onClick: o[14] || (o[14] = j((...u) => c.closeLightBox && c.closeLightBox(...u), ["stop"]))
  }, [
    q(dt, {
      mode: "out-in",
      name: "vib-container-transition",
      onAfterEnter: c.enableImageTransition,
      onBeforeLeave: c.disableImageTransition
    }, {
      default: mt(() => [
        f.media && f.media.length > 0 ? ke((v(), d("div", Si, [
          T("div", {
            class: "vib-content",
            onClick: o[0] || (o[0] = j(() => {
            }, ["stop"]))
          }, [
            q(dt, {
              mode: "out-in",
              name: a.imageTransitionName
            }, {
              default: mt(() => [
                c.currentMedia.type == null || c.currentMedia.type == "image" ? (v(), d("img", {
                  key: c.currentMedia.src,
                  src: c.currentMedia.src,
                  srcset: c.currentMedia.srcset || "",
                  class: "vib-image",
                  alt: c.currentMedia.caption
                }, null, 8, Oi)) : f.media[a.select].type == "youtube" ? (v(), d("div", xi, [
                  T("iframe", {
                    src: "https://www.youtube.com/embed/" + f.media[a.select].id + "?showinfo=0",
                    width: "560",
                    height: "315",
                    frameborder: "0",
                    allowfullscreen: ""
                  }, null, 8, Li)
                ])) : c.currentMedia.type == "video" ? (v(), d("video", {
                  key: c.currentMedia.sources[0].src,
                  ref: "video",
                  controls: "",
                  width: c.currentMedia.width,
                  height: c.currentMedia.height,
                  autoplay: c.currentMedia.autoplay
                }, [
                  (v(!0), d(Ye, null, Fe(c.currentMedia.sources, (u) => (v(), d("source", {
                    key: u.src,
                    src: u.src,
                    type: u.type
                  }, null, 8, Di))), 128))
                ], 8, wi)) : W("", !0)
              ]),
              _: 1
            }, 8, ["name"])
          ]),
          f.showThumbs ? (v(), d("div", {
            key: 0,
            class: Z(["vib-thumbnail-wrapper vib-hideable", { "vib-hidden": a.controlsHidden }]),
            onClick: o[1] || (o[1] = j(() => {
            }, ["stop"])),
            onMouseover: o[2] || (o[2] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[3] || (o[3] = (u) => a.interfaceHovered = !1)
          }, [
            (v(!0), d(Ye, null, Fe(c.imagesThumb, (u, S) => ke((v(), d("div", {
              key: typeof u.thumb == "string" ? `${u.thumb}${S}` : S,
              style: ei({ backgroundImage: "url(" + u.thumb + ")" }),
              class: Z("vib-thumbnail" + (a.select === S ? "-active" : "")),
              onClick: j((B) => c.showImage(S), ["stop"])
            }, [
              u.type == "video" || u.type == "youtube" ? Q(l.$slots, "videoIcon", { key: 0 }, () => [
                q($)
              ]) : W("", !0)
            ], 14, Hi)), [
              [Be, S >= c.thumbIndex.begin && S <= c.thumbIndex.end]
            ])), 128))
          ], 34)) : W("", !0),
          T("div", {
            class: Z(["vib-footer vib-hideable", { "vib-hidden": a.controlsHidden }]),
            onMouseover: o[4] || (o[4] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[5] || (o[5] = (u) => a.interfaceHovered = !1)
          }, [
            Q(l.$slots, "customCaption", { currentMedia: c.currentMedia }, () => [
              ke(T("div", {
                innerHTML: c.currentMedia.caption
              }, null, 8, Ri), [
                [Be, f.showCaption]
              ])
            ]),
            T("div", Ui, [
              Q(l.$slots, "footer", {
                current: a.select + 1,
                total: f.media.length
              }, () => [
                ti(pt(a.select + 1) + " / " + pt(f.media.length), 1)
              ])
            ])
          ], 34),
          f.closable ? (v(), d("button", {
            key: 1,
            type: "button",
            title: f.closeText,
            class: Z(["vib-close vib-hideable", { "vib-hidden": a.controlsHidden }]),
            onMouseover: o[6] || (o[6] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[7] || (o[7] = (u) => a.interfaceHovered = !1)
          }, [
            Q(l.$slots, "close", {}, () => [
              q(ee)
            ])
          ], 42, ki)) : W("", !0),
          f.media.length > 1 ? (v(), d("button", {
            key: 2,
            type: "button",
            class: Z(["vib-arrow vib-arrow-left vib-hideable", { "vib-hidden": a.controlsHidden }]),
            title: f.previousText,
            onClick: o[8] || (o[8] = j((u) => c.previousImage(), ["stop"])),
            onMouseover: o[9] || (o[9] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[10] || (o[10] = (u) => a.interfaceHovered = !1)
          }, [
            Q(l.$slots, "previous", {}, () => [
              q(N)
            ])
          ], 42, Bi)) : W("", !0),
          f.media.length > 1 ? (v(), d("button", {
            key: 3,
            type: "button",
            class: Z(["vib-arrow vib-arrow-right vib-hideable", { "vib-hidden": a.controlsHidden }]),
            title: f.nextText,
            onClick: o[11] || (o[11] = j((u) => c.nextImage(), ["stop"])),
            onMouseover: o[12] || (o[12] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[13] || (o[13] = (u) => a.interfaceHovered = !1)
          }, [
            Q(l.$slots, "next", {}, () => [
              q(M)
            ])
          ], 42, Yi)) : W("", !0)
        ], 512)), [
          [Be, a.lightBoxShown]
        ]) : W("", !0)
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onBeforeLeave"])
  ]);
}
const Vi = /* @__PURE__ */ K(Mi, [["render", Fi]]), y = "https://vue-it-bigger.rusiczki.net/", Xi = [
  {
    type: "youtube",
    id: "WsptdUFthWI",
    thumb: "https://img.youtube.com/vi/WsptdUFthWI/hqdefault.jpg",
    caption: "Closer - The Chainsmokers ft. Halsey (Boyce Avenue ft. Sarah Hyland cover) on Spotify & Apple"
  },
  {
    thumb: "https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRx1TQ3PfnhWmLUWcxrGj3atDCZVTVBKetMOWVVQ4ipIStW03pY",
    sources: [
      {
        src: "https://www.w3schools.com/html/mov_bbb.mp4",
        type: "video/mp4"
      }
    ],
    type: "video",
    caption: "Monsters Inc.",
    width: 800,
    height: 600
  },
  {
    thumb: y + "01-zell-am-see-thumbnail.jpg",
    src: y + "01-zell-am-see.jpg",
    caption: "Zell am See, Austria"
  },
  {
    thumb: y + "02-balea-lake-chalet-thumbnail.jpg",
    src: y + "02-balea-lake-chalet.jpg",
    caption: "Balea Lake Chalet, Romania"
  },
  {
    thumb: y + "03-maybug-thumbnail.jpg",
    src: y + "03-maybug.jpg",
    caption: "Maybug"
  },
  {
    thumb: y + "04-rc-car-thumbnail.jpg",
    src: y + "04-rc-car.jpg",
    caption: "An RC Car"
  },
  {
    thumb: y + "05-tourists-thumbnail.jpg",
    src: y + "05-tourists.jpg",
    caption: "Two tourists on a mountain"
  },
  {
    thumb: y + "06-dog-thumbnail.jpg",
    src: y + "06-dog.jpg",
    caption: "Dog"
  },
  {
    thumb: y + "07-beer-thumbnail.jpg",
    src: y + "07-beer.jpg",
    caption: "Mmm, Beer! - This should be a short description, as it is after all, beer, but let's make it long so that we can test how the footer looks"
  },
  {
    thumb: y + "08-roosters-crest-thumbnail.jpg",
    src: y + "08-roosters-crest.jpg",
    caption: "The Rooster's Crest"
  }
], Wi = {
  components: {
    LightBox: Vi
  },
  data() {
    return {
      media: Xi
    };
  },
  methods: {
    openGallery(l) {
      this.$refs.lightbox.showImage(l);
    }
  }
}, qi = { id: "app" }, zi = { style: { margin: "0", padding: "0" } }, Gi = ["src", "onClick"];
function ji(l, o, f, J, a, c) {
  const $ = he("LightBox");
  return v(), d("div", qi, [
    T("div", null, [
      T("ul", zi, [
        (v(!0), d(Ye, null, Fe(a.media, (ee, N) => (v(), d("li", {
          key: N,
          style: { display: "inline-block", margin: "0 5px 5px 0" }
        }, [
          T("img", {
            src: ee.thumb,
            style: { height: "100px", cursor: "pointer" },
            onClick: (M) => c.openGallery(N)
          }, null, 8, Gi)
        ]))), 128))
      ]),
      q($, {
        ref: "lightbox",
        media: a.media,
        "show-caption": !0,
        "show-light-box": !1
      }, null, 8, ["media"])
    ])
  ]);
}
const Zi = /* @__PURE__ */ K(Wi, [["render", ji]]), Qi = ii(Zi);
Qi.mount("#app");
