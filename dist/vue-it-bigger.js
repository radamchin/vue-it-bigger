import { openBlock as m, createElementBlock as p, createElementVNode as _, resolveComponent as _e, withModifiers as z, createVNode as G, Transition as ut, withCtx as ft, withDirectives as Ue, Fragment as vt, renderList as dt, createCommentVNode as X, normalizeClass as Z, normalizeStyle as $t, renderSlot as j, vShow as ke, createTextVNode as ei, toDisplayString as mt } from "vue";
const re = (l, o) => {
  const f = l.__vccOpts || l;
  for (const [se, a] of o)
    f[se] = a;
  return f;
}, ti = {}, ii = /* @__PURE__ */ _("svg", {
  fill: "white",
  x: "0px",
  y: "0px",
  width: "100%",
  height: "100%",
  viewBox: "0 0 512 512"
}, [
  /* @__PURE__ */ _("path", { d: "M213.7,256L213.7,256L213.7,256L380.9,81.9c4.2-4.3,4.1-11.4-0.2-15.8l-29.9-30.6c-4.3-4.4-11.3-4.5-15.5-0.2L131.1,247.9 c-2.2,2.2-3.2,5.2-3,8.1c-0.1,3,0.9,5.9,3,8.1l204.2,212.7c4.2,4.3,11.2,4.2,15.5-0.2l29.9-30.6c4.3-4.4,4.4-11.5,0.2-15.8 L213.7,256z" })
], -1), ni = [
  ii
];
function ri(l, o) {
  return m(), p("span", null, ni);
}
const si = /* @__PURE__ */ re(ti, [["render", ri]]), oi = {}, ai = /* @__PURE__ */ _("svg", {
  fill: "white",
  x: "0px",
  y: "0px",
  width: "100%",
  height: "100%",
  viewBox: "0 0 512 512"
}, [
  /* @__PURE__ */ _("path", { d: "M298.3,256L298.3,256L298.3,256L131.1,81.9c-4.2-4.3-4.1-11.4,0.2-15.8l29.9-30.6c4.3-4.4,11.3-4.5,15.5-0.2l204.2,212.7 c2.2,2.2,3.2,5.2,3,8.1c0.1,3-0.9,5.9-3,8.1L176.7,476.8c-4.2,4.3-11.2,4.2-15.5-0.2L131.3,446c-4.3-4.4-4.4-11.5-0.2-15.8 L298.3,256z" })
], -1), li = [
  ai
];
function hi(l, o) {
  return m(), p("span", null, li);
}
const ci = /* @__PURE__ */ re(oi, [["render", hi]]), ui = {}, fi = {
  fill: "white",
  x: "0px",
  y: "0px",
  width: "100%",
  height: "100%",
  viewBox: "0 0 512 512",
  style: { "enable-background": "new 0 0 512 512" }
}, vi = /* @__PURE__ */ _("path", { d: "M443.6,387.1L312.4,255.4l131.5-130c5.4-5.4,5.4-14.2,0-19.6l-37.4-37.6c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4 L256,197.8L124.9,68.3c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4L68,105.9c-5.4,5.4-5.4,14.2,0,19.6l131.5,130L68.4,387.1 c-2.6,2.6-4.1,6.1-4.1,9.8c0,3.7,1.4,7.2,4.1,9.8l37.4,37.6c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1L256,313.1l130.7,131.1 c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1l37.4-37.6c2.6-2.6,4.1-6.1,4.1-9.8C447.7,393.2,446.2,389.7,443.6,387.1z" }, null, -1), di = [
  vi
];
function mi(l, o) {
  return m(), p("span", null, [
    (m(), p("svg", fi, di))
  ]);
}
const pi = /* @__PURE__ */ re(ui, [["render", mi]]), Ti = {}, gi = {
  x: "0px",
  y: "0px",
  viewBox: "0 0 271.953 271.953",
  style: { "enable-background": "new 0 0 271.953 271.953", margin: "12px" },
  "xml:space": "preserve"
}, yi = /* @__PURE__ */ _("g", null, [
  /* @__PURE__ */ _("g", null, [
    /* @__PURE__ */ _("path", {
      style: { fill: "#fff" },
      d: "M135.977,271.953c75.097,0,135.977-60.879,135.977-135.977S211.074,0,135.977,0S0,60.879,0,135.977    S60.879,271.953,135.977,271.953z M250.197,135.977c0,62.979-51.241,114.22-114.22,114.22s-114.22-51.241-114.22-114.22    s51.241-114.22,114.22-114.22S250.197,72.998,250.197,135.977z"
    }),
    /* @__PURE__ */ _("path", {
      style: { fill: "#fff" },
      d: "M112.295,205.031c2.692,1.115,5.434,1.659,8.235,1.659c5.662,0,11.183-2.208,15.344-6.375    l48.93-48.952c8.496-8.496,8.485-22.273-0.011-30.769l-48.957-48.952c-4.161-4.161-9.73-6.375-15.393-6.375    c-2.801,0-5.461,0.544-8.153,1.659c-8.126,3.367-13.255,11.297-13.255,20.097v97.903    C99.034,193.729,104.164,201.664,112.295,205.031z M120.791,88.613v-1.588l48.952,48.952l-48.952,48.952V88.613z"
    })
  ])
], -1), Ei = [
  yi
];
function _i(l, o) {
  return m(), p("svg", gi, Ei);
}
const Ii = /* @__PURE__ */ re(Ti, [["render", _i]]);
function bi(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var pt = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(l) {
  (function(o, f, se, a) {
    var c = ["", "webkit", "Moz", "MS", "ms", "o"], Ie = f.createElement("div"), be = "function", R = Math.round, L = Math.abs, u = Date.now;
    function P(e, t, i) {
      return setTimeout(Ne(e, i), t);
    }
    function k(e, t, i) {
      return Array.isArray(e) ? (x(e, i[t], i), !0) : !1;
    }
    function x(e, t, i) {
      var n;
      if (e)
        if (e.forEach)
          e.forEach(t, i);
        else if (e.length !== a)
          for (n = 0; n < e.length; )
            t.call(i, e[n], n, e), n++;
        else
          for (n in e)
            e.hasOwnProperty(n) && t.call(i, e[n], n, e);
    }
    function Ye(e, t, i) {
      var n = "DEPRECATED METHOD: " + t + `
` + i + ` AT 
`;
      return function() {
        var r = new Error("get-stack-trace"), s = r && r.stack ? r.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", h = o.console && (o.console.warn || o.console.log);
        return h && h.call(o.console, n, s), e.apply(this, arguments);
      };
    }
    var A;
    typeof Object.assign != "function" ? A = function(t) {
      if (t === a || t === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var i = Object(t), n = 1; n < arguments.length; n++) {
        var r = arguments[n];
        if (r !== a && r !== null)
          for (var s in r)
            r.hasOwnProperty(s) && (i[s] = r[s]);
      }
      return i;
    } : A = Object.assign;
    var Be = Ye(function(t, i, n) {
      for (var r = Object.keys(i), s = 0; s < r.length; )
        (!n || n && t[r[s]] === a) && (t[r[s]] = i[r[s]]), s++;
      return t;
    }, "extend", "Use `assign`."), Tt = Ye(function(t, i) {
      return Be(t, i, !0);
    }, "merge", "Use `assign`.");
    function I(e, t, i) {
      var n = t.prototype, r;
      r = e.prototype = Object.create(n), r.constructor = e, r._super = n, i && A(r, i);
    }
    function Ne(e, t) {
      return function() {
        return e.apply(t, arguments);
      };
    }
    function Ce(e, t) {
      return typeof e == be ? e.apply(t && t[0] || a, t) : e;
    }
    function Fe(e, t) {
      return e === a ? t : e;
    }
    function oe(e, t, i) {
      x(le(t), function(n) {
        e.addEventListener(n, i, !1);
      });
    }
    function ae(e, t, i) {
      x(le(t), function(n) {
        e.removeEventListener(n, i, !1);
      });
    }
    function Ve(e, t) {
      for (; e; ) {
        if (e == t)
          return !0;
        e = e.parentNode;
      }
      return !1;
    }
    function Y(e, t) {
      return e.indexOf(t) > -1;
    }
    function le(e) {
      return e.trim().split(/\s+/g);
    }
    function q(e, t, i) {
      if (e.indexOf && !i)
        return e.indexOf(t);
      for (var n = 0; n < e.length; ) {
        if (i && e[n][i] == t || !i && e[n] === t)
          return n;
        n++;
      }
      return -1;
    }
    function he(e) {
      return Array.prototype.slice.call(e, 0);
    }
    function Xe(e, t, i) {
      for (var n = [], r = [], s = 0; s < e.length; ) {
        var h = t ? e[s][t] : e[s];
        q(r, h) < 0 && n.push(e[s]), r[s] = h, s++;
      }
      return i && (t ? n = n.sort(function(T, y) {
        return T[t] > y[t];
      }) : n = n.sort()), n;
    }
    function ce(e, t) {
      for (var i, n, r = t[0].toUpperCase() + t.slice(1), s = 0; s < c.length; ) {
        if (i = c[s], n = i ? i + r : t, n in e)
          return n;
        s++;
      }
      return a;
    }
    var gt = 1;
    function yt() {
      return gt++;
    }
    function qe(e) {
      var t = e.ownerDocument || e;
      return t.defaultView || t.parentWindow || o;
    }
    var Et = /mobile|tablet|ip(ad|hone|od)|android/i, We = "ontouchstart" in o, _t = ce(o, "PointerEvent") !== a, It = We && Et.test(navigator.userAgent), J = "touch", bt = "pen", Pe = "mouse", Nt = "kinect", Ct = 25, g = 1, B = 2, v = 4, E = 8, ue = 1, K = 2, Q = 4, $ = 8, ee = 16, M = K | Q, F = $ | ee, ze = M | F, Ge = ["x", "y"], fe = ["clientX", "clientY"];
    function b(e, t) {
      var i = this;
      this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function(n) {
        Ce(e.options.enable, [e]) && i.handler(n);
      }, this.init();
    }
    b.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && oe(this.element, this.evEl, this.domHandler), this.evTarget && oe(this.target, this.evTarget, this.domHandler), this.evWin && oe(qe(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && ae(this.element, this.evEl, this.domHandler), this.evTarget && ae(this.target, this.evTarget, this.domHandler), this.evWin && ae(qe(this.element), this.evWin, this.domHandler);
      }
    };
    function Pt(e) {
      var t, i = e.options.inputClass;
      return i ? t = i : _t ? t = Me : It ? t = me : We ? t = Se : t = de, new t(e, At);
    }
    function At(e, t, i) {
      var n = i.pointers.length, r = i.changedPointers.length, s = t & g && n - r === 0, h = t & (v | E) && n - r === 0;
      i.isFirst = !!s, i.isFinal = !!h, s && (e.session = {}), i.eventType = t, Mt(e, i), e.emit("hammer.input", i), e.recognize(i), e.session.prevInput = i;
    }
    function Mt(e, t) {
      var i = e.session, n = t.pointers, r = n.length;
      i.firstInput || (i.firstInput = Ze(t)), r > 1 && !i.firstMultiple ? i.firstMultiple = Ze(t) : r === 1 && (i.firstMultiple = !1);
      var s = i.firstInput, h = i.firstMultiple, d = h ? h.center : s.center, T = t.center = je(n);
      t.timeStamp = u(), t.deltaTime = t.timeStamp - s.timeStamp, t.angle = Ae(d, T), t.distance = ve(d, T), St(i, t), t.offsetDirection = Ke(t.deltaX, t.deltaY);
      var y = Je(t.deltaTime, t.deltaX, t.deltaY);
      t.overallVelocityX = y.x, t.overallVelocityY = y.y, t.overallVelocity = L(y.x) > L(y.y) ? y.x : y.y, t.scale = h ? xt(h.pointers, n) : 1, t.rotation = h ? Lt(h.pointers, n) : 0, t.maxPointers = i.prevInput ? t.pointers.length > i.prevInput.maxPointers ? t.pointers.length : i.prevInput.maxPointers : t.pointers.length, Ot(i, t);
      var O = e.element;
      Ve(t.srcEvent.target, O) && (O = t.srcEvent.target), t.target = O;
    }
    function St(e, t) {
      var i = t.center, n = e.offsetDelta || {}, r = e.prevDelta || {}, s = e.prevInput || {};
      (t.eventType === g || s.eventType === v) && (r = e.prevDelta = {
        x: s.deltaX || 0,
        y: s.deltaY || 0
      }, n = e.offsetDelta = {
        x: i.x,
        y: i.y
      }), t.deltaX = r.x + (i.x - n.x), t.deltaY = r.y + (i.y - n.y);
    }
    function Ot(e, t) {
      var i = e.lastInterval || t, n = t.timeStamp - i.timeStamp, r, s, h, d;
      if (t.eventType != E && (n > Ct || i.velocity === a)) {
        var T = t.deltaX - i.deltaX, y = t.deltaY - i.deltaY, O = Je(n, T, y);
        s = O.x, h = O.y, r = L(O.x) > L(O.y) ? O.x : O.y, d = Ke(T, y), e.lastInterval = t;
      } else
        r = i.velocity, s = i.velocityX, h = i.velocityY, d = i.direction;
      t.velocity = r, t.velocityX = s, t.velocityY = h, t.direction = d;
    }
    function Ze(e) {
      for (var t = [], i = 0; i < e.pointers.length; )
        t[i] = {
          clientX: R(e.pointers[i].clientX),
          clientY: R(e.pointers[i].clientY)
        }, i++;
      return {
        timeStamp: u(),
        pointers: t,
        center: je(t),
        deltaX: e.deltaX,
        deltaY: e.deltaY
      };
    }
    function je(e) {
      var t = e.length;
      if (t === 1)
        return {
          x: R(e[0].clientX),
          y: R(e[0].clientY)
        };
      for (var i = 0, n = 0, r = 0; r < t; )
        i += e[r].clientX, n += e[r].clientY, r++;
      return {
        x: R(i / t),
        y: R(n / t)
      };
    }
    function Je(e, t, i) {
      return {
        x: t / e || 0,
        y: i / e || 0
      };
    }
    function Ke(e, t) {
      return e === t ? ue : L(e) >= L(t) ? e < 0 ? K : Q : t < 0 ? $ : ee;
    }
    function ve(e, t, i) {
      i || (i = Ge);
      var n = t[i[0]] - e[i[0]], r = t[i[1]] - e[i[1]];
      return Math.sqrt(n * n + r * r);
    }
    function Ae(e, t, i) {
      i || (i = Ge);
      var n = t[i[0]] - e[i[0]], r = t[i[1]] - e[i[1]];
      return Math.atan2(r, n) * 180 / Math.PI;
    }
    function Lt(e, t) {
      return Ae(t[1], t[0], fe) + Ae(e[1], e[0], fe);
    }
    function xt(e, t) {
      return ve(t[0], t[1], fe) / ve(e[0], e[1], fe);
    }
    var wt = {
      mousedown: g,
      mousemove: B,
      mouseup: v
    }, Dt = "mousedown", Ht = "mousemove mouseup";
    function de() {
      this.evEl = Dt, this.evWin = Ht, this.pressed = !1, b.apply(this, arguments);
    }
    I(de, b, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(t) {
        var i = wt[t.type];
        i & g && t.button === 0 && (this.pressed = !0), i & B && t.which !== 1 && (i = v), this.pressed && (i & v && (this.pressed = !1), this.callback(this.manager, i, {
          pointers: [t],
          changedPointers: [t],
          pointerType: Pe,
          srcEvent: t
        }));
      }
    });
    var Rt = {
      pointerdown: g,
      pointermove: B,
      pointerup: v,
      pointercancel: E,
      pointerout: E
    }, Ut = {
      2: J,
      3: bt,
      4: Pe,
      5: Nt
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, Qe = "pointerdown", $e = "pointermove pointerup pointercancel";
    o.MSPointerEvent && !o.PointerEvent && (Qe = "MSPointerDown", $e = "MSPointerMove MSPointerUp MSPointerCancel");
    function Me() {
      this.evEl = Qe, this.evWin = $e, b.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    I(Me, b, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(t) {
        var i = this.store, n = !1, r = t.type.toLowerCase().replace("ms", ""), s = Rt[r], h = Ut[t.pointerType] || t.pointerType, d = h == J, T = q(i, t.pointerId, "pointerId");
        s & g && (t.button === 0 || d) ? T < 0 && (i.push(t), T = i.length - 1) : s & (v | E) && (n = !0), !(T < 0) && (i[T] = t, this.callback(this.manager, s, {
          pointers: i,
          changedPointers: [t],
          pointerType: h,
          srcEvent: t
        }), n && i.splice(T, 1));
      }
    });
    var kt = {
      touchstart: g,
      touchmove: B,
      touchend: v,
      touchcancel: E
    }, Yt = "touchstart", Bt = "touchstart touchmove touchend touchcancel";
    function et() {
      this.evTarget = Yt, this.evWin = Bt, this.started = !1, b.apply(this, arguments);
    }
    I(et, b, {
      handler: function(t) {
        var i = kt[t.type];
        if (i === g && (this.started = !0), !!this.started) {
          var n = Ft.call(this, t, i);
          i & (v | E) && n[0].length - n[1].length === 0 && (this.started = !1), this.callback(this.manager, i, {
            pointers: n[0],
            changedPointers: n[1],
            pointerType: J,
            srcEvent: t
          });
        }
      }
    });
    function Ft(e, t) {
      var i = he(e.touches), n = he(e.changedTouches);
      return t & (v | E) && (i = Xe(i.concat(n), "identifier", !0)), [i, n];
    }
    var Vt = {
      touchstart: g,
      touchmove: B,
      touchend: v,
      touchcancel: E
    }, Xt = "touchstart touchmove touchend touchcancel";
    function me() {
      this.evTarget = Xt, this.targetIds = {}, b.apply(this, arguments);
    }
    I(me, b, {
      handler: function(t) {
        var i = Vt[t.type], n = qt.call(this, t, i);
        n && this.callback(this.manager, i, {
          pointers: n[0],
          changedPointers: n[1],
          pointerType: J,
          srcEvent: t
        });
      }
    });
    function qt(e, t) {
      var i = he(e.touches), n = this.targetIds;
      if (t & (g | B) && i.length === 1)
        return n[i[0].identifier] = !0, [i, i];
      var r, s, h = he(e.changedTouches), d = [], T = this.target;
      if (s = i.filter(function(y) {
        return Ve(y.target, T);
      }), t === g)
        for (r = 0; r < s.length; )
          n[s[r].identifier] = !0, r++;
      for (r = 0; r < h.length; )
        n[h[r].identifier] && d.push(h[r]), t & (v | E) && delete n[h[r].identifier], r++;
      if (d.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          Xe(s.concat(d), "identifier", !0),
          d
        ];
    }
    var Wt = 2500, tt = 25;
    function Se() {
      b.apply(this, arguments);
      var e = Ne(this.handler, this);
      this.touch = new me(this.manager, e), this.mouse = new de(this.manager, e), this.primaryTouch = null, this.lastTouches = [];
    }
    I(Se, b, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(t, i, n) {
        var r = n.pointerType == J, s = n.pointerType == Pe;
        if (!(s && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) {
          if (r)
            zt.call(this, i, n);
          else if (s && Gt.call(this, n))
            return;
          this.callback(t, i, n);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function zt(e, t) {
      e & g ? (this.primaryTouch = t.changedPointers[0].identifier, it.call(this, t)) : e & (v | E) && it.call(this, t);
    }
    function it(e) {
      var t = e.changedPointers[0];
      if (t.identifier === this.primaryTouch) {
        var i = { x: t.clientX, y: t.clientY };
        this.lastTouches.push(i);
        var n = this.lastTouches, r = function() {
          var s = n.indexOf(i);
          s > -1 && n.splice(s, 1);
        };
        setTimeout(r, Wt);
      }
    }
    function Gt(e) {
      for (var t = e.srcEvent.clientX, i = e.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
        var r = this.lastTouches[n], s = Math.abs(t - r.x), h = Math.abs(i - r.y);
        if (s <= tt && h <= tt)
          return !0;
      }
      return !1;
    }
    var nt = ce(Ie.style, "touchAction"), rt = nt !== a, st = "compute", ot = "auto", Oe = "manipulation", V = "none", te = "pan-x", ie = "pan-y", pe = jt();
    function Le(e, t) {
      this.manager = e, this.set(t);
    }
    Le.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(e) {
        e == st && (e = this.compute()), rt && this.manager.element.style && pe[e] && (this.manager.element.style[nt] = e), this.actions = e.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var e = [];
        return x(this.manager.recognizers, function(t) {
          Ce(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()));
        }), Zt(e.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(e) {
        var t = e.srcEvent, i = e.offsetDirection;
        if (this.manager.session.prevented) {
          t.preventDefault();
          return;
        }
        var n = this.actions, r = Y(n, V) && !pe[V], s = Y(n, ie) && !pe[ie], h = Y(n, te) && !pe[te];
        if (r) {
          var d = e.pointers.length === 1, T = e.distance < 2, y = e.deltaTime < 250;
          if (d && T && y)
            return;
        }
        if (!(h && s) && (r || s && i & M || h && i & F))
          return this.preventSrc(t);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(e) {
        this.manager.session.prevented = !0, e.preventDefault();
      }
    };
    function Zt(e) {
      if (Y(e, V))
        return V;
      var t = Y(e, te), i = Y(e, ie);
      return t && i ? V : t || i ? t ? te : ie : Y(e, Oe) ? Oe : ot;
    }
    function jt() {
      if (!rt)
        return !1;
      var e = {}, t = o.CSS && o.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(i) {
        e[i] = t ? o.CSS.supports("touch-action", i) : !0;
      }), e;
    }
    var Te = 1, N = 2, W = 4, U = 8, w = U, ne = 16, S = 32;
    function D(e) {
      this.options = A({}, this.defaults, e || {}), this.id = yt(), this.manager = null, this.options.enable = Fe(this.options.enable, !0), this.state = Te, this.simultaneous = {}, this.requireFail = [];
    }
    D.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(e) {
        return A(this.options, e), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(e) {
        if (k(e, "recognizeWith", this))
          return this;
        var t = this.simultaneous;
        return e = ge(e, this), t[e.id] || (t[e.id] = e, e.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(e) {
        return k(e, "dropRecognizeWith", this) ? this : (e = ge(e, this), delete this.simultaneous[e.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(e) {
        if (k(e, "requireFailure", this))
          return this;
        var t = this.requireFail;
        return e = ge(e, this), q(t, e) === -1 && (t.push(e), e.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(e) {
        if (k(e, "dropRequireFailure", this))
          return this;
        e = ge(e, this);
        var t = q(this.requireFail, e);
        return t > -1 && this.requireFail.splice(t, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(e) {
        return !!this.simultaneous[e.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(e) {
        var t = this, i = this.state;
        function n(r) {
          t.manager.emit(r, e);
        }
        i < U && n(t.options.event + at(i)), n(t.options.event), e.additionalEvent && n(e.additionalEvent), i >= U && n(t.options.event + at(i));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(e) {
        if (this.canEmit())
          return this.emit(e);
        this.state = S;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var e = 0; e < this.requireFail.length; ) {
          if (!(this.requireFail[e].state & (S | Te)))
            return !1;
          e++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(e) {
        var t = A({}, e);
        if (!Ce(this.options.enable, [this, t])) {
          this.reset(), this.state = S;
          return;
        }
        this.state & (w | ne | S) && (this.state = Te), this.state = this.process(t), this.state & (N | W | U | ne) && this.tryEmit(t);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(e) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function at(e) {
      return e & ne ? "cancel" : e & U ? "end" : e & W ? "move" : e & N ? "start" : "";
    }
    function lt(e) {
      return e == ee ? "down" : e == $ ? "up" : e == K ? "left" : e == Q ? "right" : "";
    }
    function ge(e, t) {
      var i = t.manager;
      return i ? i.get(e) : e;
    }
    function C() {
      D.apply(this, arguments);
    }
    I(C, D, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(e) {
        var t = this.options.pointers;
        return t === 0 || e.pointers.length === t;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(e) {
        var t = this.state, i = e.eventType, n = t & (N | W), r = this.attrTest(e);
        return n && (i & E || !r) ? t | ne : n || r ? i & v ? t | U : t & N ? t | W : N : S;
      }
    });
    function ye() {
      C.apply(this, arguments), this.pX = null, this.pY = null;
    }
    I(ye, C, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: ze
      },
      getTouchAction: function() {
        var e = this.options.direction, t = [];
        return e & M && t.push(ie), e & F && t.push(te), t;
      },
      directionTest: function(e) {
        var t = this.options, i = !0, n = e.distance, r = e.direction, s = e.deltaX, h = e.deltaY;
        return r & t.direction || (t.direction & M ? (r = s === 0 ? ue : s < 0 ? K : Q, i = s != this.pX, n = Math.abs(e.deltaX)) : (r = h === 0 ? ue : h < 0 ? $ : ee, i = h != this.pY, n = Math.abs(e.deltaY))), e.direction = r, i && n > t.threshold && r & t.direction;
      },
      attrTest: function(e) {
        return C.prototype.attrTest.call(this, e) && (this.state & N || !(this.state & N) && this.directionTest(e));
      },
      emit: function(e) {
        this.pX = e.deltaX, this.pY = e.deltaY;
        var t = lt(e.direction);
        t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e);
      }
    });
    function xe() {
      C.apply(this, arguments);
    }
    I(xe, C, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [V];
      },
      attrTest: function(e) {
        return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & N);
      },
      emit: function(e) {
        if (e.scale !== 1) {
          var t = e.scale < 1 ? "in" : "out";
          e.additionalEvent = this.options.event + t;
        }
        this._super.emit.call(this, e);
      }
    });
    function we() {
      D.apply(this, arguments), this._timer = null, this._input = null;
    }
    I(we, D, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [ot];
      },
      process: function(e) {
        var t = this.options, i = e.pointers.length === t.pointers, n = e.distance < t.threshold, r = e.deltaTime > t.time;
        if (this._input = e, !n || !i || e.eventType & (v | E) && !r)
          this.reset();
        else if (e.eventType & g)
          this.reset(), this._timer = P(function() {
            this.state = w, this.tryEmit();
          }, t.time, this);
        else if (e.eventType & v)
          return w;
        return S;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(e) {
        this.state === w && (e && e.eventType & v ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = u(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function De() {
      C.apply(this, arguments);
    }
    I(De, C, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [V];
      },
      attrTest: function(e) {
        return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & N);
      }
    });
    function He() {
      C.apply(this, arguments);
    }
    I(He, C, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: M | F,
        pointers: 1
      },
      getTouchAction: function() {
        return ye.prototype.getTouchAction.call(this);
      },
      attrTest: function(e) {
        var t = this.options.direction, i;
        return t & (M | F) ? i = e.overallVelocity : t & M ? i = e.overallVelocityX : t & F && (i = e.overallVelocityY), this._super.attrTest.call(this, e) && t & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && L(i) > this.options.velocity && e.eventType & v;
      },
      emit: function(e) {
        var t = lt(e.offsetDirection);
        t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e);
      }
    });
    function Ee() {
      D.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    I(Ee, D, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [Oe];
      },
      process: function(e) {
        var t = this.options, i = e.pointers.length === t.pointers, n = e.distance < t.threshold, r = e.deltaTime < t.time;
        if (this.reset(), e.eventType & g && this.count === 0)
          return this.failTimeout();
        if (n && r && i) {
          if (e.eventType != v)
            return this.failTimeout();
          var s = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, h = !this.pCenter || ve(this.pCenter, e.center) < t.posThreshold;
          this.pTime = e.timeStamp, this.pCenter = e.center, !h || !s ? this.count = 1 : this.count += 1, this._input = e;
          var d = this.count % t.taps;
          if (d === 0)
            return this.hasRequireFailures() ? (this._timer = P(function() {
              this.state = w, this.tryEmit();
            }, t.interval, this), N) : w;
        }
        return S;
      },
      failTimeout: function() {
        return this._timer = P(function() {
          this.state = S;
        }, this.options.interval, this), S;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == w && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function H(e, t) {
      return t = t || {}, t.recognizers = Fe(t.recognizers, H.defaults.preset), new Re(e, t);
    }
    H.VERSION = "2.0.7", H.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: st,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [De, { enable: !1 }],
        [xe, { enable: !1 }, ["rotate"]],
        [He, { direction: M }],
        [ye, { direction: M }, ["swipe"]],
        [Ee],
        [Ee, { event: "doubletap", taps: 2 }, ["tap"]],
        [we]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var Jt = 1, ht = 2;
    function Re(e, t) {
      this.options = A({}, H.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = Pt(this), this.touchAction = new Le(this, this.options.touchAction), ct(this, !0), x(this.options.recognizers, function(i) {
        var n = this.add(new i[0](i[1]));
        i[2] && n.recognizeWith(i[2]), i[3] && n.requireFailure(i[3]);
      }, this);
    }
    Re.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(e) {
        return A(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(e) {
        this.session.stopped = e ? ht : Jt;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(e) {
        var t = this.session;
        if (!t.stopped) {
          this.touchAction.preventDefaults(e);
          var i, n = this.recognizers, r = t.curRecognizer;
          (!r || r && r.state & w) && (r = t.curRecognizer = null);
          for (var s = 0; s < n.length; )
            i = n[s], t.stopped !== ht && // 1
            (!r || i == r || // 2
            i.canRecognizeWith(r)) ? i.recognize(e) : i.reset(), !r && i.state & (N | W | U) && (r = t.curRecognizer = i), s++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(e) {
        if (e instanceof D)
          return e;
        for (var t = this.recognizers, i = 0; i < t.length; i++)
          if (t[i].options.event == e)
            return t[i];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(e) {
        if (k(e, "add", this))
          return this;
        var t = this.get(e.options.event);
        return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(e) {
        if (k(e, "remove", this))
          return this;
        if (e = this.get(e), e) {
          var t = this.recognizers, i = q(t, e);
          i !== -1 && (t.splice(i, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(e, t) {
        if (e !== a && t !== a) {
          var i = this.handlers;
          return x(le(e), function(n) {
            i[n] = i[n] || [], i[n].push(t);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(e, t) {
        if (e !== a) {
          var i = this.handlers;
          return x(le(e), function(n) {
            t ? i[n] && i[n].splice(q(i[n], t), 1) : delete i[n];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(e, t) {
        this.options.domEvents && Kt(e, t);
        var i = this.handlers[e] && this.handlers[e].slice();
        if (!(!i || !i.length)) {
          t.type = e, t.preventDefault = function() {
            t.srcEvent.preventDefault();
          };
          for (var n = 0; n < i.length; )
            i[n](t), n++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && ct(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function ct(e, t) {
      var i = e.element;
      if (i.style) {
        var n;
        x(e.options.cssProps, function(r, s) {
          n = ce(i.style, s), t ? (e.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = e.oldCssProps[n] || "";
        }), t || (e.oldCssProps = {});
      }
    }
    function Kt(e, t) {
      var i = f.createEvent("Event");
      i.initEvent(e, !0, !0), i.gesture = t, t.target.dispatchEvent(i);
    }
    A(H, {
      INPUT_START: g,
      INPUT_MOVE: B,
      INPUT_END: v,
      INPUT_CANCEL: E,
      STATE_POSSIBLE: Te,
      STATE_BEGAN: N,
      STATE_CHANGED: W,
      STATE_ENDED: U,
      STATE_RECOGNIZED: w,
      STATE_CANCELLED: ne,
      STATE_FAILED: S,
      DIRECTION_NONE: ue,
      DIRECTION_LEFT: K,
      DIRECTION_RIGHT: Q,
      DIRECTION_UP: $,
      DIRECTION_DOWN: ee,
      DIRECTION_HORIZONTAL: M,
      DIRECTION_VERTICAL: F,
      DIRECTION_ALL: ze,
      Manager: Re,
      Input: b,
      TouchAction: Le,
      TouchInput: me,
      MouseInput: de,
      PointerEventInput: Me,
      TouchMouseInput: Se,
      SingleTouchInput: et,
      Recognizer: D,
      AttrRecognizer: C,
      Tap: Ee,
      Pan: ye,
      Swipe: He,
      Pinch: xe,
      Rotate: De,
      Press: we,
      on: oe,
      off: ae,
      each: x,
      merge: Tt,
      extend: Be,
      assign: A,
      inherit: I,
      bindFn: Ne,
      prefixed: ce
    });
    var Qt = typeof o < "u" ? o : typeof self < "u" ? self : {};
    Qt.Hammer = H, typeof a == "function" && a.amd ? a(function() {
      return H;
    }) : l.exports ? l.exports = H : o[se] = H;
  })(window, document, "Hammer");
})(pt);
var Ni = pt.exports;
const Ci = /* @__PURE__ */ bi(Ni);
const Pi = {
  components: {
    LeftArrowIcon: si,
    RightArrowIcon: ci,
    CloseIcon: pi,
    VideoIcon: Ii
  },
  props: {
    media: {
      type: Array,
      required: !0
    },
    disableScroll: {
      type: Boolean,
      default: !0
    },
    showLightBox: {
      type: Boolean,
      default: !0
    },
    closable: {
      type: Boolean,
      default: !0
    },
    startAt: {
      type: Number,
      default: 0
    },
    nThumbs: {
      type: Number,
      default: 7
    },
    showThumbs: {
      type: Boolean,
      default: !0
    },
    // Mode
    autoPlay: {
      type: Boolean,
      default: !1
    },
    autoPlayTime: {
      type: Number,
      default: 3e3
    },
    interfaceHideTime: {
      type: Number,
      default: 3e3
    },
    showCaption: {
      type: Boolean,
      default: !1
    },
    lengthToLoadMore: {
      type: Number,
      default: 0
    },
    closeText: {
      type: String,
      default: "Close (Esc)"
    },
    previousText: {
      type: String,
      default: "Previous"
    },
    nextText: {
      type: String,
      default: "Next"
    }
  },
  data() {
    return {
      select: this.startAt,
      lightBoxShown: this.showLightBox,
      controlsHidden: !1,
      imageTransitionName: "vib-image-no-transition",
      timer: null,
      interactionTimer: null,
      interfaceHovered: !1
    };
  },
  computed: {
    currentMedia() {
      return this.media[this.select];
    },
    thumbIndex() {
      const l = Math.floor(this.nThumbs / 2);
      return this.select >= l && this.select < this.media.length - l ? {
        begin: this.select - l + (1 - this.nThumbs % 2),
        end: this.select + l
      } : this.select < l ? {
        begin: 0,
        end: this.nThumbs - 1
      } : {
        begin: this.media.length - this.nThumbs,
        end: this.media.length - 1
      };
    },
    imagesThumb() {
      return this.media.map(({ thumb: l, type: o }) => ({ thumb: l, type: o }));
    }
  },
  watch: {
    lightBoxShown(l) {
      document != null && this.onToggleLightBox(l);
    },
    select() {
      this.$emit("onImageChanged", this.select), this.select >= this.media.length - this.lengthToLoadMore - 1 && this.$emit("onLoad"), this.select === this.media.length - 1 && this.$emit("onLastIndex"), this.select === 0 && this.$emit("onFirstIndex"), this.select === this.startAt && this.$emit("onStartIndex");
    }
  },
  mounted() {
    if (this.autoPlay && (this.timer = setInterval(this.nextImage, this.autoPlayTime)), this.onToggleLightBox(this.lightBoxShown), this.$refs.container) {
      const l = new Ci(this.$refs.container);
      l.on("swiperight", this.previousImage), l.on("swipeleft", this.nextImage), this.$refs.container.addEventListener("mousedown", this.handleMouseActivity), this.$refs.container.addEventListener("mousemove", this.handleMouseActivity), this.$refs.container.addEventListener("touchmove", this.handleMouseActivity);
    }
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.addKeyEvent), this.autoPlay && clearInterval(this.timer), this.$refs.container && (this.$refs.container.removeEventListener("mousedown", this.handleMouseActivity), this.$refs.container.removeEventListener("mousemove", this.handleMouseActivity), this.$refs.container.removeEventListener("touchmove", this.handleMouseActivity));
  },
  methods: {
    onLightBoxOpen() {
      this.$emit("onOpened"), this.disableScroll && document.querySelector("html").classList.add("no-scroll"), document.querySelector("body").classList.add("vib-open"), document.addEventListener("keydown", this.addKeyEvent), this.$refs.video && this.$refs.video.autoplay && this.$refs.video.play();
    },
    onLightBoxClose() {
      this.$emit("onClosed"), this.disableScroll && document.querySelector("html").classList.remove("no-scroll"), document.querySelector("body").classList.remove("vib-open"), document.removeEventListener("keydown", this.addKeyEvent), this.$refs.video && (this.$refs.video.pause(), this.$refs.video.currentTime = "0");
    },
    onToggleLightBox(l) {
      l ? this.onLightBoxOpen() : this.onLightBoxClose();
    },
    showImage(l) {
      this.select = l, this.controlsHidden = !1, this.lightBoxShown = !0;
    },
    addKeyEvent(l) {
      switch (l.keyCode) {
        case 37:
          this.previousImage();
          break;
        case 39:
          this.nextImage();
          break;
        case 27:
          this.closeLightBox();
          break;
      }
    },
    closeLightBox() {
      this.$refs.video && this.$refs.video.pause(), this.closable && (this.lightBoxShown = !1);
    },
    nextImage() {
      this.select = (this.select + 1) % this.media.length;
    },
    previousImage() {
      this.select = (this.select + this.media.length - 1) % this.media.length;
    },
    enableImageTransition() {
      this.handleMouseActivity(), this.imageTransitionName = "vib-image-transition";
    },
    disableImageTransition() {
      this.imageTransitionName = "vib-image-no-transition";
    },
    handleMouseActivity() {
      clearTimeout(this.interactionTimer), this.controlsHidden && (this.controlsHidden = !1), this.interfaceHovered ? this.stopInteractionTimer() : this.startInteractionTimer();
    },
    startInteractionTimer() {
      this.interactionTimer = setTimeout(() => {
        this.controlsHidden = !0;
      }, this.interfaceHideTime);
    },
    stopInteractionTimer() {
      this.interactionTimer = null;
    }
  }
}, Ai = {
  key: 0,
  ref: "container",
  class: "vib-container"
}, Mi = ["src", "srcset", "alt"], Si = {
  key: 1,
  class: "video-background"
}, Oi = ["src"], Li = ["width", "height", "autoplay"], xi = ["src", "type"], wi = ["onClick"], Di = ["innerHTML"], Hi = { class: "vib-footer-count" }, Ri = ["title"], Ui = ["title"], ki = ["title"];
function Yi(l, o, f, se, a, c) {
  const Ie = _e("VideoIcon"), be = _e("CloseIcon"), R = _e("LeftArrowIcon"), L = _e("RightArrowIcon");
  return m(), p("div", {
    onClick: o[14] || (o[14] = z((...u) => c.closeLightBox && c.closeLightBox(...u), ["stop"]))
  }, [
    G(ut, {
      mode: "out-in",
      name: "vib-container-transition",
      onAfterEnter: c.enableImageTransition,
      onBeforeLeave: c.disableImageTransition
    }, {
      default: ft(() => [
        f.media && f.media.length > 0 ? Ue((m(), p("div", Ai, [
          _("div", {
            class: "vib-content",
            onClick: o[0] || (o[0] = z(() => {
            }, ["stop"]))
          }, [
            G(ut, {
              mode: "out-in",
              name: a.imageTransitionName
            }, {
              default: ft(() => [
                c.currentMedia.type == null || c.currentMedia.type == "image" ? (m(), p("img", {
                  key: c.currentMedia.src,
                  src: c.currentMedia.src,
                  srcset: c.currentMedia.srcset || "",
                  class: "vib-image",
                  alt: c.currentMedia.caption
                }, null, 8, Mi)) : f.media[a.select].type == "youtube" ? (m(), p("div", Si, [
                  _("iframe", {
                    src: "https://www.youtube.com/embed/" + f.media[a.select].id + "?showinfo=0",
                    width: "560",
                    height: "315",
                    frameborder: "0",
                    allowfullscreen: ""
                  }, null, 8, Oi)
                ])) : c.currentMedia.type == "video" ? (m(), p("video", {
                  key: c.currentMedia.sources[0].src,
                  ref: "video",
                  controls: "",
                  width: c.currentMedia.width,
                  height: c.currentMedia.height,
                  autoplay: c.currentMedia.autoplay
                }, [
                  (m(!0), p(vt, null, dt(c.currentMedia.sources, (u) => (m(), p("source", {
                    key: u.src,
                    src: u.src,
                    type: u.type
                  }, null, 8, xi))), 128))
                ], 8, Li)) : X("", !0)
              ]),
              _: 1
            }, 8, ["name"])
          ]),
          f.showThumbs ? (m(), p("div", {
            key: 0,
            class: Z(["vib-thumbnail-wrapper vib-hideable", { "vib-hidden": a.controlsHidden }]),
            onClick: o[1] || (o[1] = z(() => {
            }, ["stop"])),
            onMouseover: o[2] || (o[2] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[3] || (o[3] = (u) => a.interfaceHovered = !1)
          }, [
            (m(!0), p(vt, null, dt(c.imagesThumb, (u, P) => Ue((m(), p("div", {
              key: typeof u.thumb == "string" ? `${u.thumb}${P}` : P,
              style: $t({ backgroundImage: "url(" + u.thumb + ")" }),
              class: Z("vib-thumbnail" + (a.select === P ? "-active" : "")),
              onClick: z((k) => c.showImage(P), ["stop"])
            }, [
              u.type == "video" || u.type == "youtube" ? j(l.$slots, "videoIcon", { key: 0 }, () => [
                G(Ie)
              ]) : X("", !0)
            ], 14, wi)), [
              [ke, P >= c.thumbIndex.begin && P <= c.thumbIndex.end]
            ])), 128))
          ], 34)) : X("", !0),
          _("div", {
            class: Z(["vib-footer vib-hideable", { "vib-hidden": a.controlsHidden }]),
            onMouseover: o[4] || (o[4] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[5] || (o[5] = (u) => a.interfaceHovered = !1)
          }, [
            j(l.$slots, "customCaption", { currentMedia: c.currentMedia }, () => [
              Ue(_("div", {
                innerHTML: c.currentMedia.caption
              }, null, 8, Di), [
                [ke, f.showCaption]
              ])
            ]),
            _("div", Hi, [
              j(l.$slots, "footer", {
                current: a.select + 1,
                total: f.media.length
              }, () => [
                ei(mt(a.select + 1) + " / " + mt(f.media.length), 1)
              ])
            ])
          ], 34),
          f.closable ? (m(), p("button", {
            key: 1,
            type: "button",
            title: f.closeText,
            class: Z(["vib-close vib-hideable", { "vib-hidden": a.controlsHidden }]),
            onMouseover: o[6] || (o[6] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[7] || (o[7] = (u) => a.interfaceHovered = !1)
          }, [
            j(l.$slots, "close", {}, () => [
              G(be)
            ])
          ], 42, Ri)) : X("", !0),
          f.media.length > 1 ? (m(), p("button", {
            key: 2,
            type: "button",
            class: Z(["vib-arrow vib-arrow-left vib-hideable", { "vib-hidden": a.controlsHidden }]),
            title: f.previousText,
            onClick: o[8] || (o[8] = z((u) => c.previousImage(), ["stop"])),
            onMouseover: o[9] || (o[9] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[10] || (o[10] = (u) => a.interfaceHovered = !1)
          }, [
            j(l.$slots, "previous", {}, () => [
              G(R)
            ])
          ], 42, Ui)) : X("", !0),
          f.media.length > 1 ? (m(), p("button", {
            key: 3,
            type: "button",
            class: Z(["vib-arrow vib-arrow-right vib-hideable", { "vib-hidden": a.controlsHidden }]),
            title: f.nextText,
            onClick: o[11] || (o[11] = z((u) => c.nextImage(), ["stop"])),
            onMouseover: o[12] || (o[12] = (u) => a.interfaceHovered = !0),
            onMouseleave: o[13] || (o[13] = (u) => a.interfaceHovered = !1)
          }, [
            j(l.$slots, "next", {}, () => [
              G(L)
            ])
          ], 42, ki)) : X("", !0)
        ], 512)), [
          [ke, a.lightBoxShown]
        ]) : X("", !0)
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onBeforeLeave"])
  ]);
}
const Fi = /* @__PURE__ */ re(Pi, [["render", Yi]]);
export {
  Fi as default
};
